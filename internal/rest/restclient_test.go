// imperfect test generated by openai
package rest

import (
	"bytes"
	"errors"
	"io"
	"net/http"
	"reflect"
	"testing"
)

type mockRoundTripper struct {
	resp *http.Response
	err  error
}

func (m *mockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	return m.resp, m.err
}

func TestRestClient_Do(t *testing.T) {
	t.Run("error creating bad request", func(t *testing.T) {
		brokenUrl := "::::"
		rc := &RestClient{client: http.DefaultClient}
		rc.Get(brokenUrl)
		if rc.err == nil {
			t.Fatal("expected error but got nil")
		}
		rc.err = nil

		rc.Put(brokenUrl, nil)
		if rc.err == nil {
			t.Fatal("expected error but got nil")
		}
		rc.err = nil

		rc.Post(brokenUrl, nil)
		if rc.err == nil {
			t.Fatal("expected error but got nil")
		}
		rc.err = nil

		rc.Delete(brokenUrl, nil)
		if rc.err == nil {
			t.Fatal("expected error but got nil")
		}
	})

	t.Run("error creating request", func(t *testing.T) {
		rc := &RestClient{}
		rc.err = errors.New("error creating request")
		_, err := rc.Get("http://example.com").Do()

		if err == nil {
			t.Error("expected an error but got nil")
		}
	})
	t.Run("error response", func(t *testing.T) {
		rc := &RestClient{
			client: &http.Client{Transport: &mockRoundTripper{resp: nil, err: errors.New("you mad")}},
		}

		_, err := rc.Get("http://example.com").Do()
		if err == nil {
			t.Error("expected an error but got nil")
		}

		_, errPost := rc.Post("http://example.com", bytes.NewReader([]byte("{}"))).Do()
		if errPost == nil {
			t.Error("expected an error for post but got nil")
		}

		_, errPut := rc.Put("http://example.com", bytes.NewReader([]byte("{}"))).Do()
		if errPut == nil {
			t.Error("expected an error for put but got nil")
		}

		_, errDelete := rc.Delete("http://example.com", bytes.NewReader([]byte("{}"))).Do()
		if errDelete == nil {
			t.Error("expected an error for delete but got nil")
		}
	})
	t.Run("successful request", func(t *testing.T) {
		expectedBody := []byte("mock response body")
		expectedStatusCode := http.StatusOK
		expectedHeaders := map[string]string{"Content-Type": "application/json"}

		mockResp := &http.Response{
			Body:       io.NopCloser(bytes.NewBuffer(expectedBody)),
			StatusCode: expectedStatusCode,
			Header:     make(http.Header),
		}
		mockResp.Header.Add("Content-Type", "application/json")

		rc := &RestClient{
			client: &http.Client{Transport: &mockRoundTripper{resp: mockResp}},
		}
		res, err := rc.Get("http://example.com").Do()

		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}

		if res.StatusCode != expectedStatusCode {
			t.Errorf("expected status code %d, got %d", expectedStatusCode, res.StatusCode)
		}

		if !bytes.Equal(res.Body, expectedBody) {
			t.Errorf("expected body %s, got %s", string(expectedBody), string(res.Body))
		}

		for key, value := range expectedHeaders {
			if res, ok := mockResp.Header[key]; !ok || len(res) == 0 || res[0] != value {
				t.Errorf("expected header %s: %s, got %v", key, value, res)
			}
		}
	})

	t.Run("successful post", func(t *testing.T) {
		expectedBody := []byte("created")
		expectedStatusCode := http.StatusCreated

		mockResp := &http.Response{
			Body:       io.NopCloser(bytes.NewBuffer(expectedBody)),
			StatusCode: expectedStatusCode,
			Header:     make(http.Header),
		}
		mockResp.Header.Add("Content-Type", "application/json")

		rc := &RestClient{client: &http.Client{Transport: &mockRoundTripper{resp: mockResp}}}
		postBody := []byte("{\"name\":1,\"age\":42}")

		res, err := rc.Post("https://test.com", bytes.NewReader(postBody)).Do()

		if err != nil {
			t.Fatalf("expected nil error")
		}

		if res.StatusCode != http.StatusCreated {
			t.Fatalf("expected %d but got %d", http.StatusCreated, res.StatusCode)
		}
	})

	t.Run("successful put", func(t *testing.T) {
		expectedBody := []byte("created")
		expectedStatusCode := http.StatusCreated

		mockResp := &http.Response{
			Body:       io.NopCloser(bytes.NewBuffer(expectedBody)),
			StatusCode: expectedStatusCode,
			Header:     make(http.Header),
		}
		mockResp.Header.Add("Content-Type", "application/json")

		rc := &RestClient{client: &http.Client{Transport: &mockRoundTripper{resp: mockResp}}}
		putBody := []byte("{\"name\":1,\"age\":43}")

		res, err := rc.Put("https://test.com", bytes.NewReader(putBody)).Do()

		if err != nil {
			t.Fatalf("expected nil error")
		}

		if res.StatusCode != http.StatusCreated {
			t.Fatalf("expected %d but got %d", http.StatusCreated, res.StatusCode)
		}
	})

	t.Run("successful delete", func(t *testing.T) {
		expectedBody := []byte("created")
		expectedStatusCode := http.StatusNoContent

		mockResp := &http.Response{
			Body:       io.NopCloser(bytes.NewBuffer(expectedBody)),
			StatusCode: expectedStatusCode,
			Header:     make(http.Header),
		}
		mockResp.Header.Add("Content-Type", "application/json")

		rc := &RestClient{client: &http.Client{Transport: &mockRoundTripper{resp: mockResp}}}
		deleteBody := []byte("{\"name\":1,\"age\":43}")

		res, err := rc.Delete("https://test.com", bytes.NewReader(deleteBody)).Do()

		if err != nil {
			t.Fatalf("expected nil error")
		}

		if res.StatusCode != http.StatusNoContent {
			t.Fatalf("expected %d but got %d", http.StatusNoContent, res.StatusCode)
		}
	})

	t.Run("headers function should add headers", func(t *testing.T) {
		expectedHeaders := map[string]string{"X": "headerX", "Y": "headerY", "Content-Type": "application/json"}
		mockResp := &http.Response{}
		rc := &RestClient{client: &http.Client{Transport: &mockRoundTripper{resp: mockResp}}}
		rc.request, _ = http.NewRequest(http.MethodGet, "http://test.com", nil)
		rc.Headers(expectedHeaders)

		for k, v := range rc.request.Header {
			if v[0] != expectedHeaders[k] {
				t.Fatalf("expected %s but got %s", expectedHeaders[k], v[0])
			}
		}
	})

	t.Run("test constructor", func(t *testing.T) {
		rc := New(http.DefaultClient)
		tp := reflect.TypeOf(rc)
		iface := reflect.TypeOf((*RestClientIface)(nil)).Elem()
		if !tp.Implements(iface) {
			t.Fatal("expected rest client to implement the interface")
		}

		rcDefault := New(nil)
		tpDefault := reflect.TypeOf(rcDefault)
		if !tpDefault.Implements(iface) {
			t.Fatal("expected rest client to implement the interface")
		}
	})
}
